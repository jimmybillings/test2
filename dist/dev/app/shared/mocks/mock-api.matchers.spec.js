"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mock_api_matchers_1 = require("./mock-api.matchers");
var api_interface_1 = require("../interfaces/api.interface");
function main() {
    describe('Mock Api Matchers', function () {
        var matchers = mock_api_matchers_1.mockApiMatchers;
        var whateverApi = 10836;
        var whateverEndpoint = 'dont_care';
        var apiSpy;
        beforeEach(function () { return apiSpy = jasmine.createSpy('apiSpy'); });
        describe('toHaveBeenCalledWithApi()', function () {
            var matcher = matchers.toHaveBeenCalledWithApi();
            describe('when expecting to have been called with a specific API', function () {
                it('passes when spy was called with a matching API', function () {
                    apiSpy(api_interface_1.Api.Identities, whateverEndpoint);
                    var result = matcher.compare(apiSpy, api_interface_1.Api.Identities);
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, api_interface_1.Api.Identities);
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with api = Api.Identities, but it was never called.");
                });
                it('fails when spy was called, but not with the expected API', function () {
                    apiSpy(api_interface_1.Api.Assets, whateverEndpoint);
                    apiSpy(api_interface_1.Api.Orders, whateverEndpoint);
                    var result = matcher.compare(apiSpy, api_interface_1.Api.Identities);
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with api = Api.Identities, but it was called with Api.Assets, Api.Orders.");
                });
                it('fails when spy was called, but with the wrong argument type', function () {
                    apiSpy('blah', whateverEndpoint);
                    var result = matcher.compare(apiSpy, api_interface_1.Api.Identities);
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual('Expected spy to have been called with api = Api.Identities, but it was called with blah.');
                });
            });
            describe('when expecting NOT to have been called with a specific API', function () {
                it('produces appropriate message when spy is called with a matching API', function () {
                    apiSpy(api_interface_1.Api.Identities, whateverEndpoint);
                    var result = matcher.compare(apiSpy, api_interface_1.Api.Identities);
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with api = Api.Identities, but it was.");
                });
            });
        });
        describe('toHaveBeenCalledWithEndpoint()', function () {
            var matcher = matchers.toHaveBeenCalledWithEndpoint();
            describe('when expecting to have been called with a specific endpoint', function () {
                it('passes when spy was called with a matching endpoint', function () {
                    apiSpy(whateverApi, 'end/point');
                    var result = matcher.compare(apiSpy, 'end/point');
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, 'end/point');
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with endpoint = 'end/point', but it was never called.");
                });
                it('fails when spy was called, but not with the expected endpoint', function () {
                    apiSpy(whateverApi, 'another/end/point');
                    apiSpy(whateverApi, 'different/end/point');
                    var result = matcher.compare(apiSpy, 'end/point');
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with endpoint = 'end/point', " +
                        "but it was called with 'another/end/point', 'different/end/point'.");
                });
            });
            describe('when expecting NOT to have been called with a specific endpoint', function () {
                it('produces appropriate message when spy is called with a matching endpoint', function () {
                    apiSpy(whateverApi, 'end/point');
                    var result = matcher.compare(apiSpy, 'end/point');
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with endpoint = 'end/point', but it was.");
                });
            });
        });
        describe('toHaveBeenCalledWithBody()', function () {
            var matcher = matchers.toHaveBeenCalledWithBody();
            describe('when expecting to have been called with a specific body option', function () {
                it('passes when spy was called with a matching body option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { body: { a: 'b' } });
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with body =\n" + JSON.stringify({ a: 'b' }, null, 2) + "\n, but it was never called.");
                });
                it('fails when spy was called, but without any body option', function () {
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with body =\n" + JSON.stringify({ a: 'b' }, null, 2) + "\n," +
                        " but it was never called with any body option.");
                });
                it('fails when spy was called, but not with the expected body option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { body: { c: 'd' } });
                    apiSpy(whateverApi, whateverEndpoint, { body: { e: 'f' } });
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with body =\n" + JSON.stringify({ a: 'b' }, null, 2) + "\n,"
                        + (" but it was called with \n" + JSON.stringify({ c: 'd' }, null, 2) + "\n- and -\n" + JSON.stringify({ e: 'f' }, null, 2) + "."));
                });
            });
            describe('when expecting NOT to have been called with a specific body option', function () {
                it('produces appropriate message when spy is called with a matching body option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { body: { a: 'b' } });
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with body =\n" + JSON.stringify({ a: 'b' }, null, 2) + "\n, but it was.");
                });
            });
            describe('when expecting to have been called with any body option', function () {
                it('passes when spy was called with a body option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { body: { a: 'b' } });
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(false);
                    expect(result.message).toEqual("Expected spy to have been called with a body option, but it was never called.");
                });
                it('fails when spy was called, but without a body option', function () {
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(false);
                    expect(result.message).toEqual('Expected spy to have been called with a body option, but it was not.');
                });
            });
            describe('when expecting NOT to have been called with any body option', function () {
                it('produces appropriate message when spy is called with a body option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { body: { c: 'd' } });
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with a body option, " +
                        ("but it was called with \n" + JSON.stringify({ c: 'd' }, null, 2) + "."));
                });
            });
        });
        describe('toHaveBeenCalledWithParameters()', function () {
            var matcher = matchers.toHaveBeenCalledWithParameters();
            describe('when expecting to have been called with a specific parameters option', function () {
                it('passes when spy was called with a matching parameters option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { parameters: { a: 'b' } });
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with "
                        + ("parameters =\n" + JSON.stringify({ a: 'b' }, null, 2) + "\n, but it was never called."));
                });
                it('fails when spy was called, but without a parameters option', function () {
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with"
                        + (" parameters =\n" + JSON.stringify({ a: 'b' }, null, 2) + "\n, ")
                        + "but it was never called with any parameters option.");
                });
                it('fails when spy was called, but not with the expected parameters option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { parameters: { c: 'd' } });
                    apiSpy(whateverApi, whateverEndpoint, { parameters: { e: 'f' } });
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with" +
                        (" parameters =\n" + JSON.stringify({ a: 'b' }, null, 2) + "\n, ") +
                        ("but it was called with \n" + JSON.stringify({ c: 'd' }, null, 2) + "\n- ") +
                        ("and -\n" + JSON.stringify({ e: 'f' }, null, 2) + "."));
                });
            });
            describe('when expecting NOT to have been called with a specific parameters option', function () {
                it('produces appropriate message when spy is called with a matching parameters option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { parameters: { a: 'b' } });
                    var result = matcher.compare(apiSpy, { a: 'b' });
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with parameters =\n" + JSON.stringify({ a: 'b' }, null, 2) + "\n, but it was.");
                });
            });
            describe('when expecting to have been called with any parameters option', function () {
                it('passes when spy was called with a parameters option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { parameters: { a: 'b' } });
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(false);
                    expect(result.message).toEqual("Expected spy to have been called with a parameters option, but it was never called.");
                });
                it('fails when spy was called, but without a parameters option', function () {
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(false);
                    expect(result.message).toEqual('Expected spy to have been called with a parameters option, but it was not.');
                });
            });
            describe('when expecting NOT to have been called with any parameters option', function () {
                it('produces appropriate message when spy was called with parameters option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { parameters: { c: 'd' } });
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with a parameters option, "
                        + ("but it was called with \n" + JSON.stringify({ c: 'd' }, null, 2) + "."));
                });
            });
        });
        describe('toHaveBeenCalledWithLoading()', function () {
            var matcher = matchers.toHaveBeenCalledWithLoading();
            describe('when expecting to have been called with a specific loadingIndicator option', function () {
                it('passes when spy was called with a matching loadingIndicator option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { loadingIndicator: true });
                    var result = matcher.compare(apiSpy, true);
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, true);
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with loadingIndicator = true, but it was never called.");
                });
                it('fails when spy was called, but without a loadingIndicator option', function () {
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, true);
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual('Expected spy to have been called with loadingIndicator = true, but it was' +
                        ' never called with any loadingIndicator option.');
                });
                it('fails when spy was called, but not with the expected loadingIndicator option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { loadingIndicator: false });
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, true);
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with loadingIndicator = true, but it was called with false.");
                });
            });
            describe('when expecting NOT to have been called with a specific loadingIndicator option', function () {
                it('produces appropriate message when spy is called with a matching loadingIndicator option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { loadingIndicator: true });
                    var result = matcher.compare(apiSpy, true);
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with loadingIndicator = true, but it was.");
                });
            });
            describe('when expecting to have been called with any loadingIndicator option', function () {
                it('passes when spy was called with a loadingIndicator option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { loadingIndicator: true });
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(false);
                    expect(result.message).toEqual("Expected spy to have been called with a loadingIndicator option, but it was never called.");
                });
                it('fails when spy was called, but without a loadingIndicator option', function () {
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(false);
                    expect(result.message).toEqual('Expected spy to have been called with a loadingIndicator option, but it was not.');
                });
            });
            describe('when expecting NOT to have been called with any loadingIndicator option', function () {
                it('produces appropriate message when spy is called with a loadingIndicator option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { loadingIndicator: true });
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with a loadingIndicator option, but it was called with true.");
                });
            });
        });
        describe('toHaveBeenCalledWithOverridingToken()', function () {
            var matcher = matchers.toHaveBeenCalledWithOverridingToken();
            describe('when expecting to have been called with a specific overridingToken option', function () {
                it('passes when spy was called with a matching overridingToken option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { overridingToken: 'some token' });
                    var result = matcher.compare(apiSpy, 'some token');
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, 'some token');
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with overridingToken = 'some token', but it was never called.");
                });
                it('fails when spy was called, but without an overridingToken option', function () {
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, 'some token');
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with overridingToken = 'some token', " +
                        "but it was never called with any overridingToken option.");
                });
                it('fails when spy was called, but not with the expected overridingToken option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { overridingToken: 'some other token' });
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, 'some token');
                    expect(result.pass).toBe(false);
                    expect(result.message)
                        .toEqual("Expected spy to have been called with overridingToken = 'some token', but it was called with 'some other token'.");
                });
            });
            describe('when expecting NOT to have been called with a specific overridingToken option', function () {
                it('produces appropriate message when spy is called with a matching overridingToken option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { overridingToken: 'some token' });
                    var result = matcher.compare(apiSpy, 'some token');
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with overridingToken = 'some token', but it was.");
                });
            });
            describe('when expecting to have been called with any overridingToken option', function () {
                it('passes when spy was called with an overridingToken option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { overridingToken: 'some token' });
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(true);
                });
                it('fails when spy was never called', function () {
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(false);
                    expect(result.message).toEqual("Expected spy to have been called with an overridingToken option, but it was never called.");
                });
                it('fails when spy was called, but without an overridingToken option', function () {
                    apiSpy(whateverApi, whateverEndpoint);
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.pass).toBe(false);
                    expect(result.message).toEqual('Expected spy to have been called with an overridingToken option, but it was not.');
                });
            });
            describe('when expecting NOT to have been called with any overridingToken option', function () {
                it('produces appropriate message when spy is called with an overridingToken option', function () {
                    apiSpy(whateverApi, whateverEndpoint, { overridingToken: 'some token' });
                    var result = matcher.compare(apiSpy, undefined);
                    expect(result.message)
                        .toEqual("Expected spy not to have been called with an overridingToken option, but it was called with 'some token'.");
                });
            });
        });
    });
}
exports.main = main;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9zaGFyZWQvbW9ja3MvbW9jay1hcGkubWF0Y2hlcnMuc3BlYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlEQUFzRDtBQUN0RCw2REFBa0Q7QUFFbEQ7SUFDRSxRQUFRLENBQUMsbUJBQW1CLEVBQUU7UUFDNUIsSUFBTSxRQUFRLEdBQUcsbUNBQXNCLENBQUM7UUFDeEMsSUFBTSxXQUFXLEdBQVEsS0FBWSxDQUFDO1FBQ3RDLElBQU0sZ0JBQWdCLEdBQVcsV0FBVyxDQUFDO1FBQzdDLElBQUksTUFBbUIsQ0FBQztRQUV4QixVQUFVLENBQUMsY0FBTSxPQUFBLE1BQU0sR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUFwQyxDQUFvQyxDQUFDLENBQUM7UUFFdkQsUUFBUSxDQUFDLDJCQUEyQixFQUFFO1lBQ3BDLElBQU0sT0FBTyxHQUEwQixRQUFRLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztZQUUxRSxRQUFRLENBQUMsd0RBQXdELEVBQUU7Z0JBQ2pFLEVBQUUsQ0FBQyxnREFBZ0QsRUFBRTtvQkFDbkQsTUFBTSxDQUFDLG1CQUFHLENBQUMsVUFBVSxFQUFFLGdCQUFnQixDQUFDLENBQUM7b0JBRXpDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLG1CQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBRXZELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNqQyxDQUFDLENBQUMsQ0FBQztnQkFFSCxFQUFFLENBQUMsaUNBQWlDLEVBQUU7b0JBQ3BDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLG1CQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBRXZELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLHNGQUFzRixDQUFDLENBQUM7Z0JBQ3JHLENBQUMsQ0FBQyxDQUFDO2dCQUVILEVBQUUsQ0FBQywwREFBMEQsRUFBRTtvQkFDN0QsTUFBTSxDQUFDLG1CQUFHLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7b0JBQ3JDLE1BQU0sQ0FBQyxtQkFBRyxDQUFDLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO29CQUVyQyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxtQkFBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO29CQUV2RCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7eUJBQ25CLE9BQU8sQ0FBQyw0R0FBNEcsQ0FBQyxDQUFDO2dCQUMzSCxDQUFDLENBQUMsQ0FBQztnQkFFSCxFQUFFLENBQUMsNkRBQTZELEVBQUU7b0JBQ2hFLE1BQU0sQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFDakMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsbUJBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztvQkFFdkQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMsMEZBQTBGLENBQUMsQ0FBQztnQkFDekcsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztZQUVILFFBQVEsQ0FBQyw0REFBNEQsRUFBRTtnQkFDckUsRUFBRSxDQUFDLHFFQUFxRSxFQUFFO29CQUN4RSxNQUFNLENBQUMsbUJBQUcsQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFFekMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsbUJBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztvQkFFdkQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7eUJBQ25CLE9BQU8sQ0FBQyw2RUFBNkUsQ0FBQyxDQUFDO2dCQUM1RixDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCxRQUFRLENBQUMsZ0NBQWdDLEVBQUU7WUFDekMsSUFBTSxPQUFPLEdBQTBCLFFBQVEsQ0FBQyw0QkFBNEIsRUFBRSxDQUFDO1lBRS9FLFFBQVEsQ0FBQyw2REFBNkQsRUFBRTtnQkFDdEUsRUFBRSxDQUFDLHFEQUFxRCxFQUFFO29CQUN4RCxNQUFNLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDO29CQUVqQyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztvQkFFcEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ2pDLENBQUMsQ0FBQyxDQUFDO2dCQUVILEVBQUUsQ0FBQyxpQ0FBaUMsRUFBRTtvQkFDcEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7b0JBRXBELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLHdGQUF3RixDQUFDLENBQUM7Z0JBQ3ZHLENBQUMsQ0FBQyxDQUFDO2dCQUVILEVBQUUsQ0FBQywrREFBK0QsRUFBRTtvQkFDbEUsTUFBTSxDQUFDLFdBQVcsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO29CQUN6QyxNQUFNLENBQUMsV0FBVyxFQUFFLHFCQUFxQixDQUFDLENBQUM7b0JBRTNDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO29CQUVwRCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7eUJBQ25CLE9BQU8sQ0FDUixnRUFBZ0U7d0JBQ2hFLG9FQUFvRSxDQUFDLENBQUM7Z0JBQzFFLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxRQUFRLENBQUMsaUVBQWlFLEVBQUU7Z0JBQzFFLEVBQUUsQ0FBQywwRUFBMEUsRUFBRTtvQkFDN0UsTUFBTSxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztvQkFFakMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7b0JBRXBELE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMsK0VBQStFLENBQUMsQ0FBQztnQkFDOUYsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsUUFBUSxDQUFDLDRCQUE0QixFQUFFO1lBQ3JDLElBQU0sT0FBTyxHQUEwQixRQUFRLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztZQUUzRSxRQUFRLENBQUMsZ0VBQWdFLEVBQUU7Z0JBQ3pFLEVBQUUsQ0FBQyx3REFBd0QsRUFBRTtvQkFDM0QsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBRTVELElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7b0JBRW5ELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNqQyxDQUFDLENBQUMsQ0FBQztnQkFFSCxFQUFFLENBQUMsaUNBQWlDLEVBQUU7b0JBQ3BDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7b0JBRW5ELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLG1EQUFpRCxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsaUNBQThCLENBQUMsQ0FBQztnQkFDakksQ0FBQyxDQUFDLENBQUM7Z0JBRUgsRUFBRSxDQUFDLHdEQUF3RCxFQUFFO29CQUMzRCxNQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFnQixDQUFDLENBQUM7b0JBQ3RDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7b0JBRW5ELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLG1EQUFpRCxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsUUFBSzt3QkFDbEcsZ0RBQWdELENBQUMsQ0FBQztnQkFDdEQsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsRUFBRSxDQUFDLGtFQUFrRSxFQUFFO29CQUNyRSxNQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFnQixFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDNUQsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBQzVELE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFFdEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztvQkFFbkQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMsbURBQWlELElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxRQUFLOzJCQUNoRywrQkFBNkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLG1CQUFjLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFHLENBQUEsQ0FBQyxDQUFDO2dCQUM1SCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBRUgsUUFBUSxDQUFDLG9FQUFvRSxFQUFFO2dCQUM3RSxFQUFFLENBQUMsNkVBQTZFLEVBQUU7b0JBQ2hGLE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUU1RCxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO29CQUVuRCxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLHVEQUFxRCxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsb0JBQWlCLENBQUMsQ0FBQztnQkFDeEgsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztZQUVILFFBQVEsQ0FBQyx5REFBeUQsRUFBRTtnQkFDbEUsRUFBRSxDQUFDLCtDQUErQyxFQUFFO29CQUNsRCxNQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFnQixFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDNUQsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBRWxELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNqQyxDQUFDLENBQUMsQ0FBQztnQkFFSCxFQUFFLENBQUMsaUNBQWlDLEVBQUU7b0JBQ3BDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO29CQUVsRCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsK0VBQStFLENBQUMsQ0FBQztnQkFDbEgsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsRUFBRSxDQUFDLHNEQUFzRCxFQUFFO29CQUN6RCxNQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFnQixDQUFDLENBQUM7b0JBRXRDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO29CQUVsRCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsc0VBQXNFLENBQUMsQ0FBQztnQkFDekcsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztZQUVILFFBQVEsQ0FBQyw2REFBNkQsRUFBRTtnQkFDdEUsRUFBRSxDQUFDLG9FQUFvRSxFQUFFO29CQUN2RSxNQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFnQixFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFFNUQsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBRWxELE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMsMkRBQTJEO3lCQUNwRSw4QkFBNEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQUcsQ0FBQSxDQUFDLENBQUM7Z0JBQ3hFLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILFFBQVEsQ0FBQyxrQ0FBa0MsRUFBRTtZQUMzQyxJQUFNLE9BQU8sR0FBMEIsUUFBUSxDQUFDLDhCQUE4QixFQUFFLENBQUM7WUFFakYsUUFBUSxDQUFDLHNFQUFzRSxFQUFFO2dCQUMvRSxFQUFFLENBQUMsOERBQThELEVBQUU7b0JBQ2pFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRSxVQUFVLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUVsRSxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO29CQUVuRCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDakMsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsRUFBRSxDQUFDLGlDQUFpQyxFQUFFO29CQUNwQyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO29CQUVuRCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7eUJBQ25CLE9BQU8sQ0FBQyx3Q0FBd0M7MkJBQy9DLG1CQUFpQixJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsaUNBQThCLENBQUEsQ0FBQyxDQUFDO2dCQUMxRixDQUFDLENBQUMsQ0FBQztnQkFFSCxFQUFFLENBQUMsNERBQTRELEVBQUU7b0JBQy9ELE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFDdEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztvQkFFbkQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMsdUNBQXVDOzJCQUM5QyxvQkFBa0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLFNBQU0sQ0FBQTswQkFDM0QscURBQXFELENBQUMsQ0FBQztnQkFDN0QsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsRUFBRSxDQUFDLHdFQUF3RSxFQUFFO29CQUMzRSxNQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFnQixFQUFFLEVBQUUsVUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDbEUsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLFVBQVUsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBQ2xFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFFdEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztvQkFFbkQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMsdUNBQXVDO3lCQUNoRCxvQkFBa0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLFNBQU0sQ0FBQTt5QkFDM0QsOEJBQTRCLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxTQUFNLENBQUE7eUJBQ3JFLFlBQVUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQUcsQ0FBQSxDQUFDLENBQUM7Z0JBQ3RELENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxRQUFRLENBQUMsMEVBQTBFLEVBQUU7Z0JBQ25GLEVBQUUsQ0FBQyxtRkFBbUYsRUFBRTtvQkFDdEYsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLFVBQVUsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBRWxFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7b0JBRW5ELE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMsNkRBQTJELElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxvQkFBaUIsQ0FBQyxDQUFDO2dCQUM5SCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBRUgsUUFBUSxDQUFDLCtEQUErRCxFQUFFO2dCQUN4RSxFQUFFLENBQUMscURBQXFELEVBQUU7b0JBQ3hELE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRSxVQUFVLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUNsRSxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztvQkFFbEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ2pDLENBQUMsQ0FBQyxDQUFDO2dCQUVILEVBQUUsQ0FBQyxpQ0FBaUMsRUFBRTtvQkFDcEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBRWxELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxxRkFBcUYsQ0FBQyxDQUFDO2dCQUN4SCxDQUFDLENBQUMsQ0FBQztnQkFFSCxFQUFFLENBQUMsNERBQTRELEVBQUU7b0JBQy9ELE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFFdEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBRWxELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyw0RUFBNEUsQ0FBQyxDQUFDO2dCQUMvRyxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBRUgsUUFBUSxDQUFDLG1FQUFtRSxFQUFFO2dCQUM1RSxFQUFFLENBQUMseUVBQXlFLEVBQUU7b0JBQzVFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRSxVQUFVLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUVsRSxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztvQkFFbEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7eUJBQ25CLE9BQU8sQ0FBQyxpRUFBaUU7MkJBQ3hFLDhCQUE0QixJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsTUFBRyxDQUFBLENBQUMsQ0FBQztnQkFDMUUsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsUUFBUSxDQUFDLCtCQUErQixFQUFFO1lBQ3hDLElBQU0sT0FBTyxHQUEwQixRQUFRLENBQUMsMkJBQTJCLEVBQUUsQ0FBQztZQUU5RSxRQUFRLENBQUMsNEVBQTRFLEVBQUU7Z0JBQ3JGLEVBQUUsQ0FBQyxvRUFBb0UsRUFBRTtvQkFDdkUsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7b0JBRWxFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUU3QyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDakMsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsRUFBRSxDQUFDLGlDQUFpQyxFQUFFO29CQUNwQyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFFN0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMseUZBQXlGLENBQUMsQ0FBQztnQkFDeEcsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsRUFBRSxDQUFDLGtFQUFrRSxFQUFFO29CQUNyRSxNQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFnQixDQUFDLENBQUM7b0JBQ3RDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUU3QyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7eUJBQ25CLE9BQU8sQ0FBQywyRUFBMkU7d0JBQ3BGLGlEQUFpRCxDQUFDLENBQUM7Z0JBQ3ZELENBQUMsQ0FBQyxDQUFDO2dCQUVILEVBQUUsQ0FBQyw4RUFBOEUsRUFBRTtvQkFDakYsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7b0JBQ25FLE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFFdEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7b0JBRTdDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLDhGQUE4RixDQUFDLENBQUM7Z0JBQzdHLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxRQUFRLENBQUMsZ0ZBQWdGLEVBQUU7Z0JBQ3pGLEVBQUUsQ0FBQyx5RkFBeUYsRUFBRTtvQkFDNUYsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7b0JBRWxFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUU3QyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLGdGQUFnRixDQUFDLENBQUM7Z0JBQy9GLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxRQUFRLENBQUMscUVBQXFFLEVBQUU7Z0JBQzlFLEVBQUUsQ0FBQywyREFBMkQsRUFBRTtvQkFDOUQsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7b0JBQ2xFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO29CQUVsRCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDakMsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsRUFBRSxDQUFDLGlDQUFpQyxFQUFFO29CQUNwQyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztvQkFFbEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLDJGQUEyRixDQUFDLENBQUM7Z0JBQzlILENBQUMsQ0FBQyxDQUFDO2dCQUVILEVBQUUsQ0FBQyxrRUFBa0UsRUFBRTtvQkFDckUsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO29CQUV0QyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztvQkFFbEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLGtGQUFrRixDQUFDLENBQUM7Z0JBQ3JILENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxRQUFRLENBQUMseUVBQXlFLEVBQUU7Z0JBQ2xGLEVBQUUsQ0FBQyxnRkFBZ0YsRUFBRTtvQkFDbkYsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7b0JBRWxFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO29CQUVsRCxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLG1HQUFtRyxDQUFDLENBQUM7Z0JBQ2xILENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILFFBQVEsQ0FBQyx1Q0FBdUMsRUFBRTtZQUNoRCxJQUFNLE9BQU8sR0FBMEIsUUFBUSxDQUFDLG1DQUFtQyxFQUFFLENBQUM7WUFFdEYsUUFBUSxDQUFDLDJFQUEyRSxFQUFFO2dCQUNwRixFQUFFLENBQUMsbUVBQW1FLEVBQUU7b0JBQ3RFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRSxlQUFlLEVBQUUsWUFBWSxFQUFFLENBQUMsQ0FBQztvQkFFekUsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7b0JBRXJELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNqQyxDQUFDLENBQUMsQ0FBQztnQkFFSCxFQUFFLENBQUMsaUNBQWlDLEVBQUU7b0JBQ3BDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO29CQUVyRCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7eUJBQ25CLE9BQU8sQ0FBQyxnR0FBZ0csQ0FBQyxDQUFDO2dCQUMvRyxDQUFDLENBQUMsQ0FBQztnQkFFSCxFQUFFLENBQUMsa0VBQWtFLEVBQUU7b0JBQ3JFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFDdEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7b0JBRXJELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLHdFQUF3RTt3QkFDakYsMERBQTBELENBQUMsQ0FBQztnQkFDaEUsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsRUFBRSxDQUFDLDZFQUE2RSxFQUFFO29CQUNoRixNQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFnQixFQUFFLEVBQUUsZUFBZSxFQUFFLGtCQUFrQixFQUFFLENBQUMsQ0FBQztvQkFDL0UsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO29CQUV0QyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQztvQkFFckQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMsa0hBQWtILENBQUMsQ0FBQztnQkFDakksQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztZQUVILFFBQVEsQ0FBQywrRUFBK0UsRUFBRTtnQkFDeEYsRUFBRSxDQUFDLHdGQUF3RixFQUFFO29CQUMzRixNQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFnQixFQUFFLEVBQUUsZUFBZSxFQUFFLFlBQVksRUFBRSxDQUFDLENBQUM7b0JBRXpFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO29CQUVyRCxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzt5QkFDbkIsT0FBTyxDQUFDLHVGQUF1RixDQUFDLENBQUM7Z0JBQ3RHLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxRQUFRLENBQUMsb0VBQW9FLEVBQUU7Z0JBQzdFLEVBQUUsQ0FBQywyREFBMkQsRUFBRTtvQkFDOUQsTUFBTSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLGVBQWUsRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFDO29CQUN6RSxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztvQkFFbEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ2pDLENBQUMsQ0FBQyxDQUFDO2dCQUVILEVBQUUsQ0FBQyxpQ0FBaUMsRUFBRTtvQkFDcEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBRWxELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQywyRkFBMkYsQ0FBQyxDQUFDO2dCQUM5SCxDQUFDLENBQUMsQ0FBQztnQkFFSCxFQUFFLENBQUMsa0VBQWtFLEVBQUU7b0JBQ3JFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFFdEMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBRWxELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxrRkFBa0YsQ0FBQyxDQUFDO2dCQUNySCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBRUgsUUFBUSxDQUFDLHdFQUF3RSxFQUFFO2dCQUNqRixFQUFFLENBQUMsZ0ZBQWdGLEVBQUU7b0JBQ25GLE1BQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRSxlQUFlLEVBQUUsWUFBWSxFQUFFLENBQUMsQ0FBQztvQkFFekUsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBRWxELE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO3lCQUNuQixPQUFPLENBQUMsMkdBQTJHLENBQUMsQ0FBQztnQkFDMUgsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBOWRELG9CQThkQyIsImZpbGUiOiJhcHAvc2hhcmVkL21vY2tzL21vY2stYXBpLm1hdGNoZXJzLnNwZWMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2NrQXBpTWF0Y2hlcnMgfSBmcm9tICcuL21vY2stYXBpLm1hdGNoZXJzJztcbmltcG9ydCB7IEFwaSB9IGZyb20gJy4uL2ludGVyZmFjZXMvYXBpLmludGVyZmFjZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWluKCkge1xuICBkZXNjcmliZSgnTW9jayBBcGkgTWF0Y2hlcnMnLCAoKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBtb2NrQXBpTWF0Y2hlcnMgYXMgYW55O1xuICAgIGNvbnN0IHdoYXRldmVyQXBpOiBBcGkgPSAxMDgzNiBhcyBBcGk7XG4gICAgY29uc3Qgd2hhdGV2ZXJFbmRwb2ludDogc3RyaW5nID0gJ2RvbnRfY2FyZSc7XG4gICAgbGV0IGFwaVNweTogamFzbWluZS5TcHk7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IGFwaVNweSA9IGphc21pbmUuY3JlYXRlU3B5KCdhcGlTcHknKSk7XG5cbiAgICBkZXNjcmliZSgndG9IYXZlQmVlbkNhbGxlZFdpdGhBcGkoKScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXI6IGphc21pbmUuQ3VzdG9tTWF0Y2hlciA9IG1hdGNoZXJzLnRvSGF2ZUJlZW5DYWxsZWRXaXRoQXBpKCk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIGV4cGVjdGluZyB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYSBzcGVjaWZpYyBBUEknLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwYXNzZXMgd2hlbiBzcHkgd2FzIGNhbGxlZCB3aXRoIGEgbWF0Y2hpbmcgQVBJJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweShBcGkuSWRlbnRpdGllcywgd2hhdGV2ZXJFbmRwb2ludCk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCBBcGkuSWRlbnRpdGllcyk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgbmV2ZXIgY2FsbGVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIEFwaS5JZGVudGl0aWVzKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYXBpID0gQXBpLklkZW50aXRpZXMsIGJ1dCBpdCB3YXMgbmV2ZXIgY2FsbGVkLmApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZmFpbHMgd2hlbiBzcHkgd2FzIGNhbGxlZCwgYnV0IG5vdCB3aXRoIHRoZSBleHBlY3RlZCBBUEknLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KEFwaS5Bc3NldHMsIHdoYXRldmVyRW5kcG9pbnQpO1xuICAgICAgICAgIGFwaVNweShBcGkuT3JkZXJzLCB3aGF0ZXZlckVuZHBvaW50KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIEFwaS5JZGVudGl0aWVzKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYXBpID0gQXBpLklkZW50aXRpZXMsIGJ1dCBpdCB3YXMgY2FsbGVkIHdpdGggQXBpLkFzc2V0cywgQXBpLk9yZGVycy5gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2ZhaWxzIHdoZW4gc3B5IHdhcyBjYWxsZWQsIGJ1dCB3aXRoIHRoZSB3cm9uZyBhcmd1bWVudCB0eXBlJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSgnYmxhaCcsIHdoYXRldmVyRW5kcG9pbnQpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIEFwaS5JZGVudGl0aWVzKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoJ0V4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYXBpID0gQXBpLklkZW50aXRpZXMsIGJ1dCBpdCB3YXMgY2FsbGVkIHdpdGggYmxhaC4nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gZXhwZWN0aW5nIE5PVCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYSBzcGVjaWZpYyBBUEknLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwcm9kdWNlcyBhcHByb3ByaWF0ZSBtZXNzYWdlIHdoZW4gc3B5IGlzIGNhbGxlZCB3aXRoIGEgbWF0Y2hpbmcgQVBJJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweShBcGkuSWRlbnRpdGllcywgd2hhdGV2ZXJFbmRwb2ludCk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCBBcGkuSWRlbnRpdGllcyk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpXG4gICAgICAgICAgICAudG9FcXVhbChgRXhwZWN0ZWQgc3B5IG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYXBpID0gQXBpLklkZW50aXRpZXMsIGJ1dCBpdCB3YXMuYCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndG9IYXZlQmVlbkNhbGxlZFdpdGhFbmRwb2ludCgpJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlcjogamFzbWluZS5DdXN0b21NYXRjaGVyID0gbWF0Y2hlcnMudG9IYXZlQmVlbkNhbGxlZFdpdGhFbmRwb2ludCgpO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiBleHBlY3RpbmcgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGEgc3BlY2lmaWMgZW5kcG9pbnQnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwYXNzZXMgd2hlbiBzcHkgd2FzIGNhbGxlZCB3aXRoIGEgbWF0Y2hpbmcgZW5kcG9pbnQnLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCAnZW5kL3BvaW50Jyk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCAnZW5kL3BvaW50Jyk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgbmV2ZXIgY2FsbGVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksICdlbmQvcG9pbnQnKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggZW5kcG9pbnQgPSAnZW5kL3BvaW50JywgYnV0IGl0IHdhcyBuZXZlciBjYWxsZWQuYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgY2FsbGVkLCBidXQgbm90IHdpdGggdGhlIGV4cGVjdGVkIGVuZHBvaW50JywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgJ2Fub3RoZXIvZW5kL3BvaW50Jyk7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCAnZGlmZmVyZW50L2VuZC9wb2ludCcpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgJ2VuZC9wb2ludCcpO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5wYXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpXG4gICAgICAgICAgICAudG9FcXVhbChcbiAgICAgICAgICAgIGBFeHBlY3RlZCBzcHkgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGVuZHBvaW50ID0gJ2VuZC9wb2ludCcsIGAgK1xuICAgICAgICAgICAgYGJ1dCBpdCB3YXMgY2FsbGVkIHdpdGggJ2Fub3RoZXIvZW5kL3BvaW50JywgJ2RpZmZlcmVudC9lbmQvcG9pbnQnLmApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiBleHBlY3RpbmcgTk9UIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhIHNwZWNpZmljIGVuZHBvaW50JywgKCkgPT4ge1xuICAgICAgICBpdCgncHJvZHVjZXMgYXBwcm9wcmlhdGUgbWVzc2FnZSB3aGVuIHNweSBpcyBjYWxsZWQgd2l0aCBhIG1hdGNoaW5nIGVuZHBvaW50JywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgJ2VuZC9wb2ludCcpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgJ2VuZC9wb2ludCcpO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSBub3QgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGVuZHBvaW50ID0gJ2VuZC9wb2ludCcsIGJ1dCBpdCB3YXMuYCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndG9IYXZlQmVlbkNhbGxlZFdpdGhCb2R5KCknLCAoKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVyOiBqYXNtaW5lLkN1c3RvbU1hdGNoZXIgPSBtYXRjaGVycy50b0hhdmVCZWVuQ2FsbGVkV2l0aEJvZHkoKTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gZXhwZWN0aW5nIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhIHNwZWNpZmljIGJvZHkgb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICBpdCgncGFzc2VzIHdoZW4gc3B5IHdhcyBjYWxsZWQgd2l0aCBhIG1hdGNoaW5nIGJvZHkgb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCwgeyBib2R5OiB7IGE6ICdiJyB9IH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgeyBhOiAnYicgfSk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgbmV2ZXIgY2FsbGVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHsgYTogJ2InIH0pO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5wYXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpXG4gICAgICAgICAgICAudG9FcXVhbChgRXhwZWN0ZWQgc3B5IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBib2R5ID1cXG4ke0pTT04uc3RyaW5naWZ5KHsgYTogJ2InIH0sIG51bGwsIDIpfVxcbiwgYnV0IGl0IHdhcyBuZXZlciBjYWxsZWQuYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgY2FsbGVkLCBidXQgd2l0aG91dCBhbnkgYm9keSBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50KTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCB7IGE6ICdiJyB9KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYm9keSA9XFxuJHtKU09OLnN0cmluZ2lmeSh7IGE6ICdiJyB9LCBudWxsLCAyKX1cXG4sYCArXG4gICAgICAgICAgICBgIGJ1dCBpdCB3YXMgbmV2ZXIgY2FsbGVkIHdpdGggYW55IGJvZHkgb3B0aW9uLmApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZmFpbHMgd2hlbiBzcHkgd2FzIGNhbGxlZCwgYnV0IG5vdCB3aXRoIHRoZSBleHBlY3RlZCBib2R5IG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQsIHsgYm9keTogeyBjOiAnZCcgfSB9KTtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQsIHsgYm9keTogeyBlOiAnZicgfSB9KTtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgeyBhOiAnYicgfSk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSlcbiAgICAgICAgICAgIC50b0VxdWFsKGBFeHBlY3RlZCBzcHkgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGJvZHkgPVxcbiR7SlNPTi5zdHJpbmdpZnkoeyBhOiAnYicgfSwgbnVsbCwgMil9XFxuLGBcbiAgICAgICAgICAgICsgYCBidXQgaXQgd2FzIGNhbGxlZCB3aXRoIFxcbiR7SlNPTi5zdHJpbmdpZnkoeyBjOiAnZCcgfSwgbnVsbCwgMil9XFxuLSBhbmQgLVxcbiR7SlNPTi5zdHJpbmdpZnkoeyBlOiAnZicgfSwgbnVsbCwgMil9LmApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiBleHBlY3RpbmcgTk9UIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhIHNwZWNpZmljIGJvZHkgb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICBpdCgncHJvZHVjZXMgYXBwcm9wcmlhdGUgbWVzc2FnZSB3aGVuIHNweSBpcyBjYWxsZWQgd2l0aCBhIG1hdGNoaW5nIGJvZHkgb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCwgeyBib2R5OiB7IGE6ICdiJyB9IH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgeyBhOiAnYicgfSk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpXG4gICAgICAgICAgICAudG9FcXVhbChgRXhwZWN0ZWQgc3B5IG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYm9keSA9XFxuJHtKU09OLnN0cmluZ2lmeSh7IGE6ICdiJyB9LCBudWxsLCAyKX1cXG4sIGJ1dCBpdCB3YXMuYCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIGV4cGVjdGluZyB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYW55IGJvZHkgb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICBpdCgncGFzc2VzIHdoZW4gc3B5IHdhcyBjYWxsZWQgd2l0aCBhIGJvZHkgb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCwgeyBib2R5OiB7IGE6ICdiJyB9IH0pO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgbmV2ZXIgY2FsbGVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9FcXVhbChgRXhwZWN0ZWQgc3B5IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhIGJvZHkgb3B0aW9uLCBidXQgaXQgd2FzIG5ldmVyIGNhbGxlZC5gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2ZhaWxzIHdoZW4gc3B5IHdhcyBjYWxsZWQsIGJ1dCB3aXRob3V0IGEgYm9keSBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9FcXVhbCgnRXhwZWN0ZWQgc3B5IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhIGJvZHkgb3B0aW9uLCBidXQgaXQgd2FzIG5vdC4nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gZXhwZWN0aW5nIE5PVCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYW55IGJvZHkgb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICBpdCgncHJvZHVjZXMgYXBwcm9wcmlhdGUgbWVzc2FnZSB3aGVuIHNweSBpcyBjYWxsZWQgd2l0aCBhIGJvZHkgb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCwgeyBib2R5OiB7IGM6ICdkJyB9IH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSlcbiAgICAgICAgICAgIC50b0VxdWFsKGBFeHBlY3RlZCBzcHkgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhIGJvZHkgb3B0aW9uLCBgICtcbiAgICAgICAgICAgIGBidXQgaXQgd2FzIGNhbGxlZCB3aXRoIFxcbiR7SlNPTi5zdHJpbmdpZnkoeyBjOiAnZCcgfSwgbnVsbCwgMil9LmApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3RvSGF2ZUJlZW5DYWxsZWRXaXRoUGFyYW1ldGVycygpJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlcjogamFzbWluZS5DdXN0b21NYXRjaGVyID0gbWF0Y2hlcnMudG9IYXZlQmVlbkNhbGxlZFdpdGhQYXJhbWV0ZXJzKCk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIGV4cGVjdGluZyB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYSBzcGVjaWZpYyBwYXJhbWV0ZXJzIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgaXQoJ3Bhc3NlcyB3aGVuIHNweSB3YXMgY2FsbGVkIHdpdGggYSBtYXRjaGluZyBwYXJhbWV0ZXJzIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQsIHsgcGFyYW1ldGVyczogeyBhOiAnYicgfSB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHsgYTogJ2InIH0pO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5wYXNzKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZmFpbHMgd2hlbiBzcHkgd2FzIG5ldmVyIGNhbGxlZCcsICgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCB7IGE6ICdiJyB9KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYFxuICAgICAgICAgICAgKyBgcGFyYW1ldGVycyA9XFxuJHtKU09OLnN0cmluZ2lmeSh7IGE6ICdiJyB9LCBudWxsLCAyKX1cXG4sIGJ1dCBpdCB3YXMgbmV2ZXIgY2FsbGVkLmApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZmFpbHMgd2hlbiBzcHkgd2FzIGNhbGxlZCwgYnV0IHdpdGhvdXQgYSBwYXJhbWV0ZXJzIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHsgYTogJ2InIH0pO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5wYXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpXG4gICAgICAgICAgICAudG9FcXVhbChgRXhwZWN0ZWQgc3B5IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aGBcbiAgICAgICAgICAgICsgYCBwYXJhbWV0ZXJzID1cXG4ke0pTT04uc3RyaW5naWZ5KHsgYTogJ2InIH0sIG51bGwsIDIpfVxcbiwgYFxuICAgICAgICAgICAgKyBgYnV0IGl0IHdhcyBuZXZlciBjYWxsZWQgd2l0aCBhbnkgcGFyYW1ldGVycyBvcHRpb24uYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgY2FsbGVkLCBidXQgbm90IHdpdGggdGhlIGV4cGVjdGVkIHBhcmFtZXRlcnMgb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCwgeyBwYXJhbWV0ZXJzOiB7IGM6ICdkJyB9IH0pO1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCwgeyBwYXJhbWV0ZXJzOiB7IGU6ICdmJyB9IH0pO1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCB7IGE6ICdiJyB9KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGhgICtcbiAgICAgICAgICAgIGAgcGFyYW1ldGVycyA9XFxuJHtKU09OLnN0cmluZ2lmeSh7IGE6ICdiJyB9LCBudWxsLCAyKX1cXG4sIGAgK1xuICAgICAgICAgICAgYGJ1dCBpdCB3YXMgY2FsbGVkIHdpdGggXFxuJHtKU09OLnN0cmluZ2lmeSh7IGM6ICdkJyB9LCBudWxsLCAyKX1cXG4tIGAgK1xuICAgICAgICAgICAgYGFuZCAtXFxuJHtKU09OLnN0cmluZ2lmeSh7IGU6ICdmJyB9LCBudWxsLCAyKX0uYCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIGV4cGVjdGluZyBOT1QgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGEgc3BlY2lmaWMgcGFyYW1ldGVycyBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwcm9kdWNlcyBhcHByb3ByaWF0ZSBtZXNzYWdlIHdoZW4gc3B5IGlzIGNhbGxlZCB3aXRoIGEgbWF0Y2hpbmcgcGFyYW1ldGVycyBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50LCB7IHBhcmFtZXRlcnM6IHsgYTogJ2InIH0gfSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCB7IGE6ICdiJyB9KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSlcbiAgICAgICAgICAgIC50b0VxdWFsKGBFeHBlY3RlZCBzcHkgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzID1cXG4ke0pTT04uc3RyaW5naWZ5KHsgYTogJ2InIH0sIG51bGwsIDIpfVxcbiwgYnV0IGl0IHdhcy5gKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gZXhwZWN0aW5nIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhbnkgcGFyYW1ldGVycyBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwYXNzZXMgd2hlbiBzcHkgd2FzIGNhbGxlZCB3aXRoIGEgcGFyYW1ldGVycyBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50LCB7IHBhcmFtZXRlcnM6IHsgYTogJ2InIH0gfSk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2ZhaWxzIHdoZW4gc3B5IHdhcyBuZXZlciBjYWxsZWQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0VxdWFsKGBFeHBlY3RlZCBzcHkgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGEgcGFyYW1ldGVycyBvcHRpb24sIGJ1dCBpdCB3YXMgbmV2ZXIgY2FsbGVkLmApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZmFpbHMgd2hlbiBzcHkgd2FzIGNhbGxlZCwgYnV0IHdpdGhvdXQgYSBwYXJhbWV0ZXJzIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0VxdWFsKCdFeHBlY3RlZCBzcHkgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGEgcGFyYW1ldGVycyBvcHRpb24sIGJ1dCBpdCB3YXMgbm90LicpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiBleHBlY3RpbmcgTk9UIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhbnkgcGFyYW1ldGVycyBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwcm9kdWNlcyBhcHByb3ByaWF0ZSBtZXNzYWdlIHdoZW4gc3B5IHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQsIHsgcGFyYW1ldGVyczogeyBjOiAnZCcgfSB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpXG4gICAgICAgICAgICAudG9FcXVhbChgRXhwZWN0ZWQgc3B5IG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYSBwYXJhbWV0ZXJzIG9wdGlvbiwgYFxuICAgICAgICAgICAgKyBgYnV0IGl0IHdhcyBjYWxsZWQgd2l0aCBcXG4ke0pTT04uc3RyaW5naWZ5KHsgYzogJ2QnIH0sIG51bGwsIDIpfS5gKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd0b0hhdmVCZWVuQ2FsbGVkV2l0aExvYWRpbmcoKScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXI6IGphc21pbmUuQ3VzdG9tTWF0Y2hlciA9IG1hdGNoZXJzLnRvSGF2ZUJlZW5DYWxsZWRXaXRoTG9hZGluZygpO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiBleHBlY3RpbmcgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGEgc3BlY2lmaWMgbG9hZGluZ0luZGljYXRvciBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwYXNzZXMgd2hlbiBzcHkgd2FzIGNhbGxlZCB3aXRoIGEgbWF0Y2hpbmcgbG9hZGluZ0luZGljYXRvciBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50LCB7IGxvYWRpbmdJbmRpY2F0b3I6IHRydWUgfSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCB0cnVlKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2ZhaWxzIHdoZW4gc3B5IHdhcyBuZXZlciBjYWxsZWQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgdHJ1ZSk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSlcbiAgICAgICAgICAgIC50b0VxdWFsKGBFeHBlY3RlZCBzcHkgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGxvYWRpbmdJbmRpY2F0b3IgPSB0cnVlLCBidXQgaXQgd2FzIG5ldmVyIGNhbGxlZC5gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2ZhaWxzIHdoZW4gc3B5IHdhcyBjYWxsZWQsIGJ1dCB3aXRob3V0IGEgbG9hZGluZ0luZGljYXRvciBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50KTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCB0cnVlKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoJ0V4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggbG9hZGluZ0luZGljYXRvciA9IHRydWUsIGJ1dCBpdCB3YXMnICtcbiAgICAgICAgICAgICcgbmV2ZXIgY2FsbGVkIHdpdGggYW55IGxvYWRpbmdJbmRpY2F0b3Igb3B0aW9uLicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZmFpbHMgd2hlbiBzcHkgd2FzIGNhbGxlZCwgYnV0IG5vdCB3aXRoIHRoZSBleHBlY3RlZCBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQsIHsgbG9hZGluZ0luZGljYXRvcjogZmFsc2UgfSk7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHRydWUpO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5wYXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpXG4gICAgICAgICAgICAudG9FcXVhbChgRXhwZWN0ZWQgc3B5IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBsb2FkaW5nSW5kaWNhdG9yID0gdHJ1ZSwgYnV0IGl0IHdhcyBjYWxsZWQgd2l0aCBmYWxzZS5gKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gZXhwZWN0aW5nIE5PVCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYSBzcGVjaWZpYyBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgaXQoJ3Byb2R1Y2VzIGFwcHJvcHJpYXRlIG1lc3NhZ2Ugd2hlbiBzcHkgaXMgY2FsbGVkIHdpdGggYSBtYXRjaGluZyBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQsIHsgbG9hZGluZ0luZGljYXRvcjogdHJ1ZSB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHRydWUpO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSBub3QgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGxvYWRpbmdJbmRpY2F0b3IgPSB0cnVlLCBidXQgaXQgd2FzLmApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiBleHBlY3RpbmcgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGFueSBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgaXQoJ3Bhc3NlcyB3aGVuIHNweSB3YXMgY2FsbGVkIHdpdGggYSBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQsIHsgbG9hZGluZ0luZGljYXRvcjogdHJ1ZSB9KTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5wYXNzKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZmFpbHMgd2hlbiBzcHkgd2FzIG5ldmVyIGNhbGxlZCcsICgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5wYXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvRXF1YWwoYEV4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYSBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbiwgYnV0IGl0IHdhcyBuZXZlciBjYWxsZWQuYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgY2FsbGVkLCBidXQgd2l0aG91dCBhIGxvYWRpbmdJbmRpY2F0b3Igb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUoYXBpU3B5LCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5wYXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvRXF1YWwoJ0V4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYSBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbiwgYnV0IGl0IHdhcyBub3QuJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIGV4cGVjdGluZyBOT1QgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGFueSBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgaXQoJ3Byb2R1Y2VzIGFwcHJvcHJpYXRlIG1lc3NhZ2Ugd2hlbiBzcHkgaXMgY2FsbGVkIHdpdGggYSBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQsIHsgbG9hZGluZ0luZGljYXRvcjogdHJ1ZSB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpXG4gICAgICAgICAgICAudG9FcXVhbChgRXhwZWN0ZWQgc3B5IG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYSBsb2FkaW5nSW5kaWNhdG9yIG9wdGlvbiwgYnV0IGl0IHdhcyBjYWxsZWQgd2l0aCB0cnVlLmApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3RvSGF2ZUJlZW5DYWxsZWRXaXRoT3ZlcnJpZGluZ1Rva2VuKCknLCAoKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVyOiBqYXNtaW5lLkN1c3RvbU1hdGNoZXIgPSBtYXRjaGVycy50b0hhdmVCZWVuQ2FsbGVkV2l0aE92ZXJyaWRpbmdUb2tlbigpO1xuXG4gICAgICBkZXNjcmliZSgnd2hlbiBleHBlY3RpbmcgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIGEgc3BlY2lmaWMgb3ZlcnJpZGluZ1Rva2VuIG9wdGlvbicsICgpID0+IHtcbiAgICAgICAgaXQoJ3Bhc3NlcyB3aGVuIHNweSB3YXMgY2FsbGVkIHdpdGggYSBtYXRjaGluZyBvdmVycmlkaW5nVG9rZW4gb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCwgeyBvdmVycmlkaW5nVG9rZW46ICdzb21lIHRva2VuJyB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksICdzb21lIHRva2VuJyk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgbmV2ZXIgY2FsbGVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksICdzb21lIHRva2VuJyk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSlcbiAgICAgICAgICAgIC50b0VxdWFsKGBFeHBlY3RlZCBzcHkgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoIG92ZXJyaWRpbmdUb2tlbiA9ICdzb21lIHRva2VuJywgYnV0IGl0IHdhcyBuZXZlciBjYWxsZWQuYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgY2FsbGVkLCBidXQgd2l0aG91dCBhbiBvdmVycmlkaW5nVG9rZW4gb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgJ3NvbWUgdG9rZW4nKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggb3ZlcnJpZGluZ1Rva2VuID0gJ3NvbWUgdG9rZW4nLCBgICtcbiAgICAgICAgICAgIGBidXQgaXQgd2FzIG5ldmVyIGNhbGxlZCB3aXRoIGFueSBvdmVycmlkaW5nVG9rZW4gb3B0aW9uLmApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZmFpbHMgd2hlbiBzcHkgd2FzIGNhbGxlZCwgYnV0IG5vdCB3aXRoIHRoZSBleHBlY3RlZCBvdmVycmlkaW5nVG9rZW4gb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICAgIGFwaVNweSh3aGF0ZXZlckFwaSwgd2hhdGV2ZXJFbmRwb2ludCwgeyBvdmVycmlkaW5nVG9rZW46ICdzb21lIG90aGVyIHRva2VuJyB9KTtcbiAgICAgICAgICBhcGlTcHkod2hhdGV2ZXJBcGksIHdoYXRldmVyRW5kcG9pbnQpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgJ3NvbWUgdG9rZW4nKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQucGFzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKVxuICAgICAgICAgICAgLnRvRXF1YWwoYEV4cGVjdGVkIHNweSB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggb3ZlcnJpZGluZ1Rva2VuID0gJ3NvbWUgdG9rZW4nLCBidXQgaXQgd2FzIGNhbGxlZCB3aXRoICdzb21lIG90aGVyIHRva2VuJy5gKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gZXhwZWN0aW5nIE5PVCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYSBzcGVjaWZpYyBvdmVycmlkaW5nVG9rZW4gb3B0aW9uJywgKCkgPT4ge1xuICAgICAgICBpdCgncHJvZHVjZXMgYXBwcm9wcmlhdGUgbWVzc2FnZSB3aGVuIHNweSBpcyBjYWxsZWQgd2l0aCBhIG1hdGNoaW5nIG92ZXJyaWRpbmdUb2tlbiBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50LCB7IG92ZXJyaWRpbmdUb2tlbjogJ3NvbWUgdG9rZW4nIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgJ3NvbWUgdG9rZW4nKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSlcbiAgICAgICAgICAgIC50b0VxdWFsKGBFeHBlY3RlZCBzcHkgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBvdmVycmlkaW5nVG9rZW4gPSAnc29tZSB0b2tlbicsIGJ1dCBpdCB3YXMuYCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd3aGVuIGV4cGVjdGluZyB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYW55IG92ZXJyaWRpbmdUb2tlbiBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwYXNzZXMgd2hlbiBzcHkgd2FzIGNhbGxlZCB3aXRoIGFuIG92ZXJyaWRpbmdUb2tlbiBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50LCB7IG92ZXJyaWRpbmdUb2tlbjogJ3NvbWUgdG9rZW4nIH0pO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdmYWlscyB3aGVuIHNweSB3YXMgbmV2ZXIgY2FsbGVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9FcXVhbChgRXhwZWN0ZWQgc3B5IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhbiBvdmVycmlkaW5nVG9rZW4gb3B0aW9uLCBidXQgaXQgd2FzIG5ldmVyIGNhbGxlZC5gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2ZhaWxzIHdoZW4gc3B5IHdhcyBjYWxsZWQsIGJ1dCB3aXRob3V0IGFuIG92ZXJyaWRpbmdUb2tlbiBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZShhcGlTcHksIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnBhc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9FcXVhbCgnRXhwZWN0ZWQgc3B5IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhbiBvdmVycmlkaW5nVG9rZW4gb3B0aW9uLCBidXQgaXQgd2FzIG5vdC4nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3doZW4gZXhwZWN0aW5nIE5PVCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggYW55IG92ZXJyaWRpbmdUb2tlbiBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwcm9kdWNlcyBhcHByb3ByaWF0ZSBtZXNzYWdlIHdoZW4gc3B5IGlzIGNhbGxlZCB3aXRoIGFuIG92ZXJyaWRpbmdUb2tlbiBvcHRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgYXBpU3B5KHdoYXRldmVyQXBpLCB3aGF0ZXZlckVuZHBvaW50LCB7IG92ZXJyaWRpbmdUb2tlbjogJ3NvbWUgdG9rZW4nIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlci5jb21wYXJlKGFwaVNweSwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSlcbiAgICAgICAgICAgIC50b0VxdWFsKGBFeHBlY3RlZCBzcHkgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhbiBvdmVycmlkaW5nVG9rZW4gb3B0aW9uLCBidXQgaXQgd2FzIGNhbGxlZCB3aXRoICdzb21lIHRva2VuJy5gKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG4iXX0=
